input {
    gelf {
        type => docker
        port => 12201
    }
}

filter {
    #
    # aggregator
    #
    if "aggregator" in [tag] {
        grok {
            patterns_dir => ["/etc/logstash/conf.d/patterns"]
            # patterns_dir => ["/Users/einar.adalsteinsson/workspace/althingi-master/log-server/patterns"]
            patterns_files_glob => "*"
            match => {
                "message" => "\[%{ISO_DATE:date}\].*%{LOGLEVEL:level}: %{AGGREGATOR} %{MEMORY}"
            }
        }
        mutate {
            add_field => {
                "[memory_usage][usage]" => "%{memory}"
                "[memory_usage][peak]" => "%{memory_peak}"
            }
        }
        mutate {
            convert => {
                "code" => "integer"
                "[memory_usage][usage]" => "integer"
                "[memory_usage][peak]" => "integer"
            }
        }
        mutate {
            rename => { "memory_usage" => "memory" }
            remove_field => ["path", "memory_peak"]
            add_field => {"tag" => "aggregator" }
        }
        date {
            match => [ "date", "yyyy-MM-dd HH:mm:ss", "ISO8601" ]
            target => "time"
        }
        mutate {
            remove_field => ["date", "port"]
        }
    }

    #
    # apache
    #
    if "apache" in [tag] {
        grok {
            match => { "message" => "%{COMBINEDAPACHELOG}" }
        }
        geoip {
            source => "clientip"
            target => geoip
            add_field => [ "[geoip][coordinates]", "%{[geoip][longitude]}" ]
            add_field => [ "[geoip][coordinates]", "%{[geoip][latitude]}"  ]
        }
        mutate {
            convert => [ "[geoip][coordinates]", "float" ]
        }
        useragent {
            source => "agent"
            target => "UA"
        }
        mutate {
            convert => ["response","integer"]
            convert => ["bytes","integer"]
            convert => ["responsetime","integer"]
            add_field => {"tag" => "apache" }
        }
        date {
            match => [ "timestamp" , "dd/MMM/yyyy:HH:mm:ss Z" ]
        }
    }

    #
    # api
    #
    if "api" in [tag] {
        grok {
            patterns_dir => ["/etc/logstash/conf.d/patterns"]
            # patterns_dir => ["/Users/einar.adalsteinsson/workspace/althingi-master/log-server/patterns"]
            patterns_files_glob => "*"
            match => {
                "message" => "\[%{ISO_DATE:date}\].*%{LOG_LEVEL:level}: %{API_PAYLOAD} %{MEMORY}"
            }
        }
        translate {
            dictionary => {
                "null" => "0"
            }
            override => true
            field => "code"
            destination => "code"
        }
        translate {
            dictionary => {
                "Response" => "SEARCH_RESPONSE"
                "Request Body" => "SEARCH_REQUEST"
                "Request Failure" => "SEARCH_FAILURE"
                "Request Success" => "SEARCH_SUCCESS"
            }
            override => true
            field => "category"
            destination => "category"
        }
        mutate {
            add_field => {
                "[memory_usage][usage]" => "%{memory}"
                "[memory_usage][peak]" => "%{memory_peak}"
            }
        }
        mutate {
            convert => {
                "code" => "integer"
                "[memory_usage][usage]" => "integer"
                "[memory_usage][peak]" => "integer"
            }
        }
        mutate {
            rename => { "memory_usage" => "memory" }
            add_field => {"tag" => "api" }
            remove_field => ["path", "memory_peak", "port"]
        }
        date {
            match => [ "date", "yyyy-MM-dd HH:mm:ss", "ISO8601" ]
            target => "time"
        }
        mutate {
            remove_field => ["date"]
        }
    }

    #
    # graphql
    #
    if "graphql" in [tag] {
        json {
            source => "message"
        }
        translate {
            dictionary => {
                "err" => "ERROR"
                "out" => "INFO"
            }
            override => true
            field => "type"
            destination => "level"
        }
        mutate {
            replace => {
                "type" => "graphql"
            }
            add_field => {"tag" => "graphql" }
        }
        json {
            skip_on_invalid_json => true
            source => "message"
            target => "json"
        }
        mutate {
            copy => { "[json][cpu]" => "cpu" }
            copy => { "[json][memory]" => "memory" }
            copy => { "[json][response][x-cache]" => "cache" }
            copy => { "[json][request][path]" => "uri" }
            join => { "[json][time]" => "." }
            copy => { "[json][time]" => "requestTime" }
        }
        translate {
            destination => "cache"
            field => "cache"
            override => true
            dictionary => {
                "HIT" => "true"
                "MISS" => "false"
            }
        }
        date {
            match => [ "timestamp", "yyyy-MM-dd HH:mm:ss", "ISO8601" ]
            target => "time"
        }
        mutate {
            convert => {
                "cache" => "boolean"
                "requestTime" => "float"
            }
            remove_field => ["json", "app_name", "path", "process_id", "timestamp", "time"]
        }
    }

    #
    # mysql
    #
    if "mysql" in [tag] {
        multiline {
            pattern => "^%{NUMBER} *%{NUMBER}"
            negate  => true
            what    => "previous"
        }
        # Strip out MySQLs messy timestamps
        grok {
            match => [ 'message', "(?m)^%{NUMBER:date} *%{NOTSPACE:time} %{GREEDYDATA:message}" ]
            overwrite => [ 'message' ]
            add_field => { "mysql_time" => "%{date} %{time}" }
        }
        # if "mysql-error" in [path] {
        #     mutate { add_field => { "level" => "ERROR"} }
        # } else if "mysql-slow" in [path] {
        #     mutate { add_field => { "level" => "WARN"} }
        # } else {
        #     mutate { add_field => { "level" => "INFO"} }
        # }
        # Check if we have a severity field
        if [message] =~ /^\[/ {
            grok {
            match => [ 'message', "(?m)\[%{NOTSPACE:severity}\] %{GREEDYDATA:message}" ]
            overwrite => [ 'message' ]
            }
        }
        # If the message contains WSREP:, it regards the galera cluster
        if  [message] =~ /WSREP:/ {
            mutate {
                replace => [ "type", "Galera" ]
            }
            grok {
                match => [ 'message', "(?m)WSREP: %{GREEDYDATA:message}" ]
                overwrite => [ 'message' ]
            }
        }
        mutate {
            remove_field => ["tags", "mysql_time", "time", "date"]
            add_field => { "tag" => "mysql" }
        }
    }
}

output {
    stdout {}

    if "aggregator" in [tag] {
        elasticsearch {
            hosts => ["http://elasticsearch:9200"]
            index => "aggregator-%{+YYYY.MM.dd}"
        }
    }

    if "apache" in [tag] {
        elasticsearch {
            hosts => ["http://elasticsearch:9200"]
            index => "apache-%{+YYYY.MM.dd}"
        }
    }

    if "api" in [tag] {
        elasticsearch {
            hosts => ["http://elasticsearch:9200"]
            index => "api-%{+YYYY.MM.dd}"
        }
    }

    if "graphql" in [tag] {
        elasticsearch {
            hosts => ["http://elasticsearch:9200"]
            index => "graphql-%{+YYYY.MM.dd}"
        }
    }

    if "mysql" in [tag] {
        elasticsearch {
            hosts => ["http://elasticsearch:9200"]
            index => "mysql-%{+YYYY.MM.dd}"
        }
    }
}