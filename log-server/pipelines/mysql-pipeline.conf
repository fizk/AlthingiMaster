# https://qbox.io/blog/mysql-logs-elasticsearch-logstash-kibana
input {
    file {
        path => "/home/mysql-*.log"
        type => "mysql"
        mode => "tail"
        start_position => "beginning"
        # sincedb_path => "/dev/null"
    }
}

filter {
   # Deal with the multi-line MySQL/MariaDB log entries
    if [type] == "mysql" {
        multiline {
            pattern => "^%{NUMBER} *%{NUMBER}"
            negate  => true
            what    => "previous"
        }
        # Strip out MySQLs messy timestamps
        grok {
            match => [ 'message', "(?m)^%{NUMBER:date} *%{NOTSPACE:time} %{GREEDYDATA:message}" ]
            overwrite => [ 'message' ]
            add_field => { "mysql_time" => "%{date} %{time}" }
        }
        if "mysql-error" in [path] {
            mutate { add_field => { "level" => "ERROR"} }
        } else if "mysql-slow" in [path] {
            mutate { add_field => { "level" => "WARN"} }
        } else {
            mutate { add_field => { "level" => "INFO"} }
        }
        # Check if we have a severity field
        if [message] =~ /^\[/ {
            grok {
            match => [ 'message', "(?m)\[%{NOTSPACE:severity}\] %{GREEDYDATA:message}" ]
            overwrite => [ 'message' ]
            }
        }
        # If the message contains WSREP:, it regards the galera cluster
        if  [message] =~ /WSREP:/ {
            mutate {
                replace => [ "type", "Galera" ]
            }
            grok {
                match => [ 'message', "(?m)WSREP: %{GREEDYDATA:message}" ]
                overwrite => [ 'message' ]
            }
        }
        mutate { remove_field => ["tags", "mysql_time", "time", "date"] }
    }
}

output {
    if [type] == "mysql" {
        # stdout { codec => rubydebug }
        elasticsearch {
            hosts => ["localhost:9200"]
            index => "mysql-%{+YYYY.MM.dd}"
        }
    }
}